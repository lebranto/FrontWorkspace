<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Function</h1>
    <h2>함수작성</h2>






    <script>

    //함수 선언식 -> 호이스팅된다.
    function foo(){
        
    }

    //함수 표현식 -> 호이스팅 안된다.
    var bar = function(){}
    bar(); // 함수표현식의 함수는 반드시 작성된 이후에 호출해야 한다.


    //즉시 실행 함수(IIFE)
    // - IIFR(Immediately invoked function Expression)
    // - 1회용 함수를 작성하고 싶을 때 사용
    // - 고유의 겹치지 않는 네이밍을 사용할 때 효융적
    // - (함수)();

    (function(){
        console.log('hello js');
    })();

    (function(){
        console.log('bye js')
    }());

    (function(){
        console.log("hello " + name);
    })('철수');


    </script>
    <h2>매개변수 | 매개인자</h2>
    <!-- 매개 변수 : 값을 전달 받기 위해 받는 변수 -->
    <!-- 매개 인자 : 실제 전달할 값-->

    <input type="button" value="실행" onclick="test1(1,2,3)">
    <input type="button" value="실행" onclick="test2()">

    <script>

        // 매개변수(parameter) : 함수 선언시 매개 인자가 담길 공간
        // 매개인사(argument) : 함수 호출시 전달할 값
        // 자바 스크립트에서는 매개 변수와 배개 인자의 개수가 달라도 문제되지 않는다.
        // 단 호출 될때는 갯수를 맞춰서 나온다. ex) test1(x), x에 1,2,3 -> 1만 나온다

        function test1(x){
            console.log("x= ", x);

            //모든 함수는 묵시적으로 arguments 배열을 가지고 있다.
            console.log(arguments); //1 2 3
        }


        function test2(){
            // 매개인자의 합을 출력하는 add메서드 작성
            add(1,2,3,4,5,6,7,8,9,10); //55 출력
            add(12.34 , 45.67) //58.01 출력
            add('a','b','c','d') // "abcd 출력"
        }

        function add(){
          
          var sum = typeof(arguments[0]) == 'number' ? 0 : "";
          var str =""
          for(var i =0 ; i<arguments.length; i++) {
            sum+=arguments[i];
         }

         if(typeof(arguments[0])=='number'){
            sum = Math.floor(sum*100)/100;
         }

          console.log(sum);
        }
    </script>

    <h2>함수 특징</h2>
    <input type="button" value="return value" onclick="test3();">
    <input type="button" value="중첩 함수" onclick="test4(10,4);">

    <script>
        // 함수의 return 구문이 없거나, return 뒤쪽에
        // 반환할 값이 없는 경우 undefined를 반환
        function test3(){
            var k = koo();
            console.log(k);
        }

        function koo(){
            return 100;
            //return;   undefined 반환

        }

        function test4(a,b){
            //a^2 + b^2 = c^2;

            var c;

            var power = function(n){
                return n**2
            }

            // ** 지수 연산자 (제곱)
            c = Math.sqrt(power(a) + power(b))
            console.log(c);

        }
    </script>

    <h2>고급 함수</h2>
    <input type="button" value="매개인자" onclick="test5()">
    <input type="button" value="리턴값" onclick="test6()">
    <input type="button" value="999" onclick="">

    <script>

        /*
            자바스크립트에서 함수는 "값"으로 취급된다.
             1. 변수에 대입할 수 있고
             2. 함수의 매개인자로 전달될 수 있고
             3. 리턴값으로 사용될 수 있다.
             
        */

        function test5(){
            //함수를 값으로서 매개인자로 전달하기
            
            exec(function(str){
                console.log("hello " + str);
            });

        }

        var names = ['html','css','javascript','jquery']

        function exec(fn){
            for(var i=0; i<names.length;i++){
                fn(names[i]);
            }

        }

        function test6(){
            //함수를 리턴값으로 사용하기
            var hello = returnFunction('hello')

            hello('js');

            returnFunction('goodbye')("js")
            //         함수          (매개인자)  이런 구조

        }

        function returnFunction(say){
            return function(name){
                //var say = say
                console.log(say + " " + name)
            }
        }

    </script>

    <h2>Closure</h2>
    <input type="button" value="golbalCounter" onclick="test7()">
    <input type="button" value="closuerCounter1" onclick="test8()">
    <input type="button" value="closuerCounter2" onclick="test9()">

    <script>
        
        var cnt = 0; // 전역변수 (Global/Script scope)
        function test7(){
            // local scope(함수 내부 스코프)
            //debugger;
            var a = 0;
            console.log("global : " +  ++cnt)

        }
       
        
        function funcY(){
        /*
            클로저(Closure)
             - 중첩함수에서 하위 함수가, 상위함수의 변수를 참조할 때 생겨나는
               스코프
             - 하위함수에서 상위 함수의 변수값을 참조하는 경우 , 하위 함수의
               closure 스코프에 변수값을 추가한다.
             - 클로져로 인해 Stack 메모리에서 상위 함수의 메모리가 제거 되더라도
               상위 함수의 변수를 그대로 가져다 사용할 수 있다.
        */
        
            var num = 100;
            function funcZ(){
                //debugger;
                console.log("num=" , num);
            }
            return funcZ;
        }    

        const myfn = funcY();
        //myfn();
        
        
        function makeClosureCounter(){
            var cnt = 0;
            return function(){
                console.log('closureScope : ' + ++cnt)
            }

        }

        var test8 = makeClosureCounter();
        var test9 = makeClosureCounter();



    </script>


</body>
</html>